use cargo_lock::Lockfile;
use cargo_metadata::{DependencyKind, Metadata, Node, NodeDep, Package, PackageId, Target};
use serde::Deserialize;
use std::collections::{HashMap, HashSet};
use std::io::Write;

#[derive(Debug, Deserialize, Default)]
struct BlackjackMetadataWrapper {
    #[serde(default)]
    blackjack: BlackjackMetadata,
}

#[derive(Debug, Deserialize, Default, Clone)]
struct CrateOpts {
    #[serde(default)]
    build_script: bool,
    #[serde(default)]
    rustc_flags: Vec<String>,
    #[serde(default)]
    replace: Option<String>,
}

#[derive(Debug, Deserialize, Default)]
struct BlackjackMetadata {
    prefix: Option<String>,

    #[serde(flatten)]
    crate_opts: HashMap<String, CrateOpts>,
}

const DEFAULT_PREFIX: &'static str = "crates_io";

fn default_crate_opts() -> Vec<(String, CrateOpts)> {
    vec![
        (
            "indexmap".to_string(),
            CrateOpts {
                rustc_flags: vec!["--cfg=has_std".to_string()],
                ..Default::default()
            },
        ),
        (
            "proc-macro2".to_string(),
            CrateOpts {
                rustc_flags: vec!["--cfg=use_proc_macro".to_string()],
                ..Default::default()
            },
        ),
        (
            "proc-macro-nested".to_string(),
            CrateOpts {
                build_script: true,
                ..Default::default()
            },
        ),
        (
            "libc".to_string(),
            CrateOpts {
                rustc_flags: vec![
                    "--cfg=libc_priv_mod_use".to_string(),
                    "--cfg=libc_union".to_string(),
                    "--cfg=libc_const_size_of".to_string(),
                    "--cfg=libc_align".to_string(),
                    "--cfg=libc_core_cvoid".to_string(),
                    "--cfg=libc_packedN".to_string(),
                    "--cfg=libc_cfg_target_vendor".to_string(),
                ],
                ..Default::default()
            },
        ),
    ]
}

impl BlackjackMetadata {
    pub fn new(package: &Package) -> BlackjackMetadata {
        let mut blackjack_metadata = if package.metadata.is_null() {
            BlackjackMetadata::default()
        } else {
            serde_json::from_value::<BlackjackMetadataWrapper>(package.metadata.clone())
                .expect("Failed to parse metadata")
                .blackjack
        };
        if let Some(p) = blackjack_metadata.prefix.as_ref() {
            if p == "" {
                blackjack_metadata.prefix = None;
            }
        }
        blackjack_metadata
    }

    pub fn merge(mut self, other: BlackjackMetadata) -> Self {
        self.prefix = match (self.prefix, other.prefix) {
            (None, None) => None,
            (Some(p), None) => Some(p),
            (None, Some(p)) => Some(p),
            (Some(a), Some(b)) => panic!(
                "Cannot merge metadata, two different prefixes given ({} vs {})",
                a, b
            ),
        };
        self.crate_opts.extend(other.crate_opts);
        self
    }
}

pub struct Blackjack {
    metadata: Metadata,
    blackjack_metadata: BlackjackMetadata,
    packages: HashMap<PackageId, Package>,
    direct_dependencies: HashSet<PackageId>,
    lockfile: Lockfile,
}

impl Blackjack {
    pub fn new(mut metadata: Metadata, lockfile: Lockfile) -> Blackjack {
        // Sort the nodes to make traversal deterministic.
        metadata
            .resolve
            .as_mut()
            .unwrap()
            .nodes
            .sort_by(|a, b| a.id.cmp(&b.id));
        let packages: HashMap<PackageId, Package> = metadata
            .packages
            .iter()
            .map(|p| (p.id.clone(), p.clone()))
            .collect();
        // Combine all metadata from all packages in the workspace.
        let mut blackjack_metadata = metadata
            .workspace_members
            .iter()
            .map(|p| packages.get(p).unwrap())
            .map(BlackjackMetadata::new)
            .fold(BlackjackMetadata::default(), |a, b| a.merge(b));
        // Add in relevant default crate options
        for (crate_name, opts) in default_crate_opts() {
            // Only add the crate options if the crate appears in the dependency graph
            if metadata.packages.iter().any(|p| p.name == crate_name) {
                blackjack_metadata
                    .crate_opts
                    .entry(crate_name)
                    .or_insert(opts);
            }
        }
        eprintln!("{:#?}", blackjack_metadata);
        let direct_dependencies = direct_dependencies(&metadata);
        Blackjack {
            metadata,
            packages,
            blackjack_metadata,
            lockfile,
            direct_dependencies,
        }
    }

    pub fn render<W: Write>(&self, mut output: W) -> Result<(), std::io::Error> {
        writeln!(
            output,
            r#""""
DO NOT EDIT!

This file is automatically @generated by blackjack.
"""
load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")

def cargo_dependencies():
"#
        )?;

        for node in self.nodes() {
            let package = self.packages.get(&node.id).unwrap();
            if !package
                .source
                .as_ref()
                .map(|s| s.is_crates_io())
                .unwrap_or(false)
            {
                // Skip packages not sourced from crates.io
                continue;
            }
            writeln!(output, "{}", self.render_archive(node, package))?;
        }
        Ok(())
    }

    fn nodes(&self) -> impl Iterator<Item = &Node> + '_ {
        self.metadata.resolve.as_ref().unwrap().nodes.iter()
    }

    fn crate_type(&self, package_id: &PackageId) -> CrateType {
        let package = self
            .metadata
            .packages
            .iter()
            .find(|p| &p.id == package_id)
            .unwrap();
        match package.targets[0].crate_types[0].as_ref() {
            "proc-macro" => CrateType::ProcMacro,
            _ => CrateType::Lib,
        }
    }

    fn render_archive(&self, node: &Node, package: &Package) -> String {
        let archive_name = if self.direct_dependencies.contains(&node.id) {
            self.prefixed_name(package)
        } else {
            format!(
                "{prefixed_name}_{version}",
                prefixed_name = self.prefixed_name(package),
                version = sanitize_version(&package.version.to_string()),
            )
        };
        format!(
            r#"
    http_archive(
        name = "{archive_name}",
        url = "https://crates.io/api/v1/crates/{name}/{version}/download",
        sha256 = "{checksum}",
        strip_prefix = "{name}-{version}",
        type = "tar.gz",
        build_file_content = """{build_file_content}""",
    )
    "#,
            archive_name = archive_name,
            name = package.name,
            version = package.version,
            checksum = self.checksum(package),
            build_file_content = self.render_build_file(node, package),
        )
    }

    fn prefixed_name(&self, package: &Package) -> String {
        format!(
            "{prefix}_{name}",
            prefix = self
                .blackjack_metadata
                .prefix
                .as_ref()
                .map(String::as_str)
                .unwrap_or(DEFAULT_PREFIX),
            name = sanitize_name(&package.name)
        )
    }

    fn dep_label(&self, package: &Package) -> String {
        // Check if a replacement label has been configured
        if let Some(CrateOpts {
            replace: Some(label),
            ..
        }) = self.blackjack_metadata.crate_opts.get(&package.name)
        {
            return label.clone();
        }

        if self.direct_dependencies.contains(&package.id) {
            format!(
                "@{prefixed_name}//:{name}",
                prefixed_name = self.prefixed_name(package),
                name = sanitize_name(&package.name)
            )
        } else {
            format!(
                "@{prefixed_name}_{version}//:{name}",
                prefixed_name = self.prefixed_name(package),
                version = sanitize_version(&package.version.to_string()),
                name = sanitize_name(&package.name),
            )
        }
    }

    fn render_build_file(&self, node: &Node, package: &Package) -> String {
        let target = library_target(package);
        let all_deps: Vec<NodeDep> = node
            .deps
            .iter()
            .filter(|d| d.dep_kinds.iter().any(|k| k.kind == DependencyKind::Normal))
            .cloned()
            .collect();

        let aliases: HashMap<String, String> = all_deps
            .iter()
            .filter_map(|d| {
                let dep_name = sanitize_name(&d.name);
                let package = &self.packages.get(&d.pkg).unwrap();
                let package_name = sanitize_name(&package.name);
                if dep_name == package_name {
                    None
                } else {
                    Some((self.dep_label(package), dep_name))
                }
            })
            .collect();

        let mut deps: Vec<String> = all_deps
            .iter()
            .filter(|d| self.crate_type(&d.pkg) == CrateType::Lib)
            .map(|d| self.dep_label(self.packages.get(&d.pkg).unwrap()))
            .collect();
        let proc_macro_deps: Vec<String> = all_deps
            .iter()
            .filter(|d| self.crate_type(&d.pkg) == CrateType::ProcMacro)
            .map(|d| self.dep_label(self.packages.get(&d.pkg).unwrap()))
            .collect();
        let crate_opts = self
            .blackjack_metadata
            .crate_opts
            .get(&package.name)
            .cloned()
            .unwrap_or_default();
        let build_script = if crate_opts.build_script {
            deps.push(":build_script".to_string());
            format!(
                r#"
load("@io_bazel_rules_rust//cargo:cargo_build_script.bzl", "cargo_build_script")

cargo_build_script(
    name = "build_script",
    srcs = ["build.rs"],
)
                "#
            )
        } else {
            "".to_string()
        };
        format!(
            r#"
load("@io_bazel_rules_rust//rust:rust.bzl", "rust_library")
{build_script}
rust_library(
    name = "{name}",
    aliases = {aliases:?},
    srcs = glob(["**/*.rs"]),
    crate_type = "{crate_type}",
    deps = {deps:?},
    proc_macro_deps = {proc_macro_deps:?},
    edition = "{edition}",
    crate_features = {crate_features:?},
    rustc_flags = ["--cap-lints=allow"] + {rustc_flags:?},
    visibility = ["//visibility:public"],
)
    "#,
            build_script = build_script,
            name = sanitize_name(&package.name),
            aliases = aliases,
            crate_type = target.crate_types[0],
            deps = deps,
            proc_macro_deps = proc_macro_deps,
            edition = target.edition,
            crate_features = node.features,
            rustc_flags = crate_opts.rustc_flags,
        )
    }

    fn checksum(&self, package: &Package) -> String {
        let lockfile_package = self
            .lockfile
            .packages
            .iter()
            .find(|p| p.name.as_str() == package.name && p.version == package.version)
            .expect("No matching lockfile entry for package");
        lockfile_package
            .checksum
            .as_ref()
            .expect("package in lockfile is missing a checksum")
            .to_string()
    }
}

#[derive(PartialEq)]
enum CrateType {
    Lib,
    ProcMacro,
}

fn sanitize_name(s: &str) -> String {
    s.replace("-", "_")
}

fn sanitize_version(s: &str) -> String {
    s.replace("+", "--PLUS--")
}

fn library_target(package: &Package) -> &Target {
    package
        .targets
        .iter()
        .find(|target| {
            target
                .kind
                .iter()
                .any(|kind| kind == "lib" || kind == "proc-macro")
        })
        .expect("dependency provides not lib or proc-macro target")
}

fn direct_dependencies(metadata: &Metadata) -> HashSet<PackageId> {
    let workspace_nodes = metadata
        .resolve
        .as_ref()
        .unwrap()
        .nodes
        .iter()
        .filter(|n| metadata.workspace_members.contains(&n.id));
    workspace_nodes
        .flat_map(|n| n.deps.iter().map(|d| d.pkg.clone()))
        .collect()
}
